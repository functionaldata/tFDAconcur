beta_ti
})
if (is.null(nrow(beta)))
beta <- matrix(beta, 1)
rownames(beta) <- names(vars)[-length(vars)]
# coefficient of determination:
#   R2 = stats::cov(X, Y)' var(X)^{-1} stats::cov(X, Y) / var(Y)
R2 <- sapply(seq_len(dim(allCov)[1]), function(i) {
tmpCov <- allCov[i, i, , ]
tmpCov[p + 1, 1:p, drop=FALSE] %*% beta[, i, drop=FALSE] / tmpCov[p + 1, p + 1]
})
R2<-sapply(R2,function(x){max(min(x,1),0)}) #capping the R2 value between 0 and 1.
muBeta <- sapply(seq_len(p), function(j) {
if (!is.function(muList[[j]])) { # scalar mean
beta[j, ] * rep(muList[[j]], length(outGrid))
} else { # functional mean
beta[j, ] * muList[[j]](outGrid)
}
})
beta0 <- muList[[Yname]](outGrid) - colSums(t(muBeta))
## enlarge output
beta0.full <- rep(NA,length(grid.full))
beta0.full[grid.index] <- beta0
if(is.vector(beta)){
beta.full <- rep(NA, length(grid.full))
beta.full[grid.index] <- beta
}else{
beta.full <- matrix(NA, dim(beta)[1], length(grid.full))
beta.full[, grid.index] <- beta
}
allCov.full <- array(NA, c(length(grid.full), length(grid.full), dim(allCov)[3], dim(allCov)[4]))
allCov.full[grid.index, grid.index,,] <- allCov
#res <- list(beta=beta, beta0 = beta0, outGrid=outGrid, cov=allCov, R2=R2, n=n)
res <- list(beta=beta.full, beta0 = beta0.full, outGrid=grid.full, cov=allCov.full, R2=R2, n=n)
if (!returnCov)
res[['cov']] <- NULL
res
}
demean <- function(vars, userBwMu, kern) {
tmp <- lapply(vars, function(x) {
if (is.numeric(x)) { # scalar
xmu <- mean(x)
x <- x - xmu
} else if (is.list(x)) { # functional
Tin <- sort(unique(unlist(x[['Lt']])))
if(is.null(userBwMu)){ # bandwidth choice for mean function is using GCV
optns <- fdapace::SetOptions(x[['Ly']], x[['Lt']], list(userBwMu=userBwMu, methodBwMu ='GCV', kernel=kern))
xmu <- fdapace:::GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1], optns)[['mu']]
} else{
xmu <- fdapace:::GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1],
list(userBwMu=userBwMu, kernel=kern))[['mu']]
}
#muFun <- stats::approxfun(Tin, xmu)
muFun <- stats::approxfun(Tin, xmu, rule=2)
x[['Ly']] <- lapply(1:length(x[['Ly']]), function(i)
x[['Ly']][[i]]- muFun(x[['Lt']][[i]]))
xmu <- muFun
}
list(x=x, mu=xmu)
})
xList <- lapply(tmp, `[[`, 'x')
muList <- lapply(tmp, `[[`, 'mu')
list(xList = xList, muList = muList)
}
## Multivariate function/scalar covariance.
# INPUTS: same as FCReg
# Output: a 4-D array containing the covariances. The first two dimensions corresponds to
# time s and t, and the last two dimensions correspond to the variables taken covariance upon.
MvCov <- function(vars, userBwCov, outGrid, kern, measurementError=TRUE, center, diag1D='none') {
if (!is.list(vars) || length(vars) < 1)
stop('`vars` needs to be a list of length >= 1')
if (diag1D == 'all' && measurementError) {
stop("Cannot assume measurement error when diag1D == 'all'")
}
isFuncVars <- sapply(vars, is.list)
p <- length(isFuncVars)
pFunc <- sum(isFuncVars)
pScaler <- sum(!isFuncVars)
if (any(isFuncVars)) {
tAll <- do.call(c, lapply(vars[isFuncVars], function(x) unlist(x[['Lt']])))
Tin <- sort(unique(tAll))
if (missing(outGrid))
outGrid <- Tin
lenoutGrid <- length(outGrid)
} else {
stop('No functional observation found')
}
# First two dimensions are for s, t, and the last two dimensions are for matrix of # random variables.
res <- array(NA, c(lenoutGrid, lenoutGrid, p, p))
for (j in seq_len(p)) {
for (i in seq_len(p)) {
#print(c(i,j))
if (j <= i) {
use1D <- diag1D == 'all' || ( diag1D == 'cross' && j != i )
covRes <- uniCov(vars[[i]], vars[[j]], userBwCov, outGrid, kern,
rmDiag = (i == j) && measurementError,
center, use1D)
if (attr(covRes, 'covType') %in% c('FF', 'SS'))
res[, , i, j] <- covRes
else {
if (nrow(covRes) == 1)   # stats::cov(scalar, function)
res[, , i, j] <- matrix(covRes, lenoutGrid, lenoutGrid, byrow=TRUE)
else                     # stats::cov(function, scalar)
res[, , i, j] <- matrix(covRes, lenoutGrid, lenoutGrid, byrow=FALSE)
}
} else { # fill up the symmetric stats::cov(y, x)
res[, , i, j] <- t(res[, , j, i])
}
}
}
return(res)
}
#X <- vars[[3]]
#Y <- vars[[2]]
uniCov <- function(X, Y, userBwCov, outGrid, kern='gauss', rmDiag=FALSE, center=TRUE, use1D=FALSE) {
flagScalerFunc <- FALSE
# Force X to be a function in the scalar-function case.
if (!is.list(X) && is.list(Y)) {
flagScalerFunc <- TRUE
tmp <- X
X <- Y
Y <- tmp
}
# Scalar-scalar
if (!is.list(X) && !is.list(Y)) {
res <- stats::cov(X, Y)
attr(res, 'covType') <- 'SS'
# Scalar-function
} else if (is.list(X) && !is.list(Y)) {
Tin <- sort(unique(unlist(X[['Lt']])))
if (center) {
if(is.null(userBwCov)){ # bandwidth choice for mean function is using GCV
optns <- fdapace::SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
Xmu <- fdapace:::GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], Tin, Tin[1], optns)[['mu']]
} else{
Xmu <- fdapace:::GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], Tin, Tin[1],
list(userBwMu=userBwCov, kernel=kern))[['mu']]
}
Ymu <- mean(Y)
} else {
Xmu <- rep(0, length(Tin))
Ymu <- 0
}
res <- fdapace::GetCrCovYZ(userBwCov, Y, Ymu, X[['Ly']], X[['Lt']], Xmu, Tin, kern)[['smoothedCC']]
res <- as.matrix(fdapace::ConvertSupport(Tin, outGrid, mu=res))
#res <- as.matrix(res)
if (flagScalerFunc)
res <- t(res)
attr(res, 'covType') <- 'FS'
# function-function
} else {
TinX <- sort(unique(unlist(X[['Lt']])))
TinY <- sort(unique(unlist(Y[['Lt']])))
noutGrid <- length(outGrid)
if (center) {
if (min(TinX) > min(outGrid) || min(TinY) > min(outGrid) ||
max(TinY) < max(outGrid) || max(TinX) < max(outGrid))
stop('Observation time points coverage too low')
if(is.null(userBwCov)){ # bandwidth choice for mean function is using GCV
optns <- fdapace::SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
Xmu <- fdapace:::GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], TinX, TinX[1], optns)[['mu']]
} else{
Xmu <- fdapace:::GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], TinX, TinX[1],
list(userBwMu=userBwCov, kernel=kern))[['mu']]
}
if(is.null(userBwCov)){
optns <- fdapace::SetOptions(Y[['Ly']], Y[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
Ymu <- fdapace:::GetSmoothedMeanCurve(Y[['Ly']], Y[['Lt']], TinX, TinX[1], optns)[['mu']]
}else{
Ymu <- fdapace:::GetSmoothedMeanCurve(Y[['Ly']], Y[['Lt']], TinY, TinY[1], list(userBwMu=userBwCov, kernel=kern))[['mu']]
}
} else {
Xmu <- rep(0, length(TinX))
Ymu <- rep(0, length(TinY))
}
names(Xmu) <- TinX
names(Ymu) <- TinY
if (use1D) {
Xvec <- unlist(X[['Ly']])
Yvec <- unlist(Y[['Ly']])
tvecX <- unlist(X[['Lt']])
tvecY <- unlist(Y[['Lt']])
if (!identical(tvecX, tvecY)){
stop('Cannot use 1D covariance smoothing if the observation time points for X and Y are different')
}
ord <- order(tvecX)
tvecX <- tvecX[ord]
Xvec <- Xvec[ord]
Yvec <- Yvec[ord]
Xcent <- Xvec - Xmu[as.character(tvecX)]
Ycent <- Yvec - Ymu[as.character(tvecX)]
if(is.null(userBwCov)){
optns <- fdapace::SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
bw_mu =  unlist(fdapace:::GCVLwls1D1(yy = Xcent * Ycent, tt = tvecX, kernel = kern, npoly = 1, nder = 0, dataType = optns$dataType) )[1]
covXY <- fdapace::Lwls1D(bw=bw_mu, kern, npoly=1L, nder=0L, xin=tvecX, yin=Xcent * Ycent, win=rep(1, length(tvecX)), xout=outGrid)
}else{
covXY <- fdapace::Lwls1D(bw=userBwCov, kern, npoly=1L, nder=0L, xin=tvecX, yin=Xcent * Ycent, win=rep(1, length(tvecX)), xout=outGrid)
}
res <- matrix(NA, noutGrid, noutGrid)
diag(res) <- covXY
} else { # use 2D smoothing
tmp <- fdapace::GetCrCovYX(userBwCov, userBwCov, X[['Ly']], X[['Lt']], Xmu,
Y[['Ly']], Y[['Lt']], Ymu, rmDiag=rmDiag, kern=kern, bwRoutine = 'grid-search')
# if(snippet){
#   tmp <- fdapace::GetCrCovYX(userBwCov, userBwCov, X[['Ly']], X[['Lt']], Xmu,
#                   Y[['Ly']], Y[['Lt']], Ymu, rmDiag=rmDiag, kern=kern, bwRoutine = 'grid-search')
# }else{
#   tmp <- fdapace::GetCrCovYX(userBwCov, userBwCov, X[['Ly']], X[['Lt']], Xmu,
#                     Y[['Ly']], Y[['Lt']], Ymu, rmDiag=rmDiag, kern=kern)
# }
gd <- tmp[['smoothGrid']]
res <- matrix(
fdapace:::interp2lin(as.numeric(gd[, 1]),
as.numeric(gd[, 2]),
matrix(as.numeric(tmp[['smoothedCC']]),
nrow(tmp[['smoothedCC']]),
ncol(tmp[['smoothedCC']])),
rep(as.numeric(outGrid), times=noutGrid),
rep(as.numeric(outGrid), each=noutGrid)),
noutGrid, noutGrid)
# rawCC <- GetRawCrCovFuncFunc(Ly1 = X[['Ly']], Lt1 = X[['Lt']], Ymu1 = Xmu, Ly2 = Y[['Ly']], Lt2 = Y[['Lt']], Ymu2 = Ymu)
# if (rmDiag) {
#   diagInd <- rawCC$tpairn[, 1] == rawCC$tpairn[, 2]
#   rawCC$tpairn <- rawCC$tpairn[!diagInd, , drop=FALSE]
#   rawCC$rawCCov <- rawCC$rawCCov[!diagInd]
# }
# res <- Lwls2D(userBwCov, kern, rawCC[['tpairn']], rawCC[['rawCCov']],
#               xout1=outGrid, xout2=outGrid, crosscov=TRUE)
}
attr(res, 'covType') <- 'FF'
}
return(res)
}
## Concurrent functional regression by imputation. This does not provide consistent estimates.
## FPCAlist: a list of functional covariates and response. Each field corresponds to a covariate.
#            The last entry is assumed to be the response if no entry is names 'Y'.
imputeConReg <- function(FPCAlist, Z, outGrid) {
if (is.null(names(FPCAlist)))
names(FPCAlist) <- c(paste0('X', seq_len(length(FPCAlist) - 1)), 'Y')
if ('Y' %in% names(FPCAlist)) {
Yname <- 'Y'
FPCAlist <- c(FPCAlist[names(FPCAlist) != 'Y'], FPCAlist['Y'])
} else
Yname <- names(FPCAlist)[length(FPCAlist)]
imputeCurves <- sapply(FPCAlist, function(x)
apply(stats::fitted(x), 1, function(fit)
stats::approx(x[['workGrid']], fit, outGrid)[['y']]),
simplify='array')
alphaBeta <- apply(imputeCurves, 1, function(XYt) {
Yt <- XYt[, ncol(XYt)]
designMat <- cbind(1, XYt[, -ncol(XYt), drop=FALSE], Z)
beta_t <- qr.solve(designMat, Yt)
return(beta_t)
})
beta0 <- alphaBeta[1, ]
beta <- alphaBeta[-1, , drop=FALSE]
return(list(beta0 = beta0, beta = beta, outGrid = outGrid))
}
## subset a list of covariates and responses.
subsetVars <- function(vars, subset) {
sapply(vars, function(x) {
if (is.list(x)) {
sapply(x, `[`, subset, drop=FALSE, simplify=FALSE)
} else if (is.numeric(x)) {
x[subset, drop=FALSE]
} else {
stop('Cannot subset variable')
}
}, simplify=FALSE)
}
## get the number of subjects for a list of covariates and responses.
lengthVars <- function(vars, subset) {
lenEach <- sapply(vars, function(x) {
if (is.list(x)) {
sapply(x, length)
} else if (is.numeric(x)) {
length(x)
} else {
stop('Cannot subset variable')
}
}, simplify=FALSE)
len <- unique(unlist(lenEach))
if (length(len) != 1) {
stop('Length of variables are not the same!')
}
return(len)
}
set.seed(1)
n <- 30
nGridIn <- 100
sparsity <- 5:10 # Sparse data sparsity
T <- round(seq(0, 1, length.out=nGridIn), 4) # Functional data support
bw <- 0.1
outGrid <- round(seq(min(T), 1, by=0.05), 2)
outGrid <- seq(min(T), max(T), by=0.05)
# Simulate functional data
mu <- T * 2 # mean function for X_1
sigma <- 1
beta_0 <- 0
beta <- rbind(cos(T), 1.5 + sin(T))
beta_2 <- 1
Z <- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 <- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(mu, n, nGridIn, byrow=TRUE)
epsilon <- rnorm(n, sd=sigma)
Y <- matrix(NA, n, nGridIn)
for (i in seq_len(n)) {
Y[i, ] <- beta_0 + beta[1,]*X_1[i, ] + beta[2,]*Z[i, 2] + epsilon[i]
}
# Sparsify functional data
set.seed(1)
X_1sp <- fdapace::Sparsify(X_1, T, sparsity)
set.seed(1)
Ysp <- fdapace::Sparsify(Y, T, sparsity)
vars <- list(X_1=X_1sp, Z_2=Z[, 2], Y=Ysp)
res2 <- ConcurReg(vars, outGrid, userBwMu = .5, userBwCov=.5,  kern='gauss',
measurementError=TRUE, diag1D='none', useGAM = FALSE, returnCov=TRUE)
res2$beta0
##
start_time <- Sys.time()
res2 <- ConcurReg(vars, outGrid, userBwMu = .5, userBwCov=.5,  kern='gauss',
measurementError=TRUE, diag1D='none', useGAM = FALSE, returnCov=TRUE)
end_time <- Sys.time()
end_time - start_time
set.seed(1)
n <- 75
nGridIn <- 150
sparsity <- 5:10 # Sparse data sparsity
T <- round(seq(0, 1, length.out=nGridIn), 4) # Functional data support
bw <- 0.1
outGrid <- round(seq(min(T), 1, by=0.05), 2)
outGrid <- seq(min(T), max(T), by=0.05)
# Simulate functional data
mu <- T * 2 # mean function for X_1
sigma <- 1
beta_0 <- 0
beta <- rbind(cos(T), 1.5 + sin(T))
beta_2 <- 1
Z <- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 <- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(mu, n, nGridIn, byrow=TRUE)
epsilon <- rnorm(n, sd=sigma)
Y <- matrix(NA, n, nGridIn)
for (i in seq_len(n)) {
Y[i, ] <- beta_0 + beta[1,]*X_1[i, ] + beta[2,]*Z[i, 2] + epsilon[i]
}
# Sparsify functional data
set.seed(1)
X_1sp <- fdapace::Sparsify(X_1, T, sparsity)
set.seed(1)
Ysp <- fdapace::Sparsify(Y, T, sparsity)
vars <- list(X_1=X_1sp, Z_2=Z[, 2], Y=Ysp)
res2 <- ConcurReg(vars, outGrid, userBwMu = .5, userBwCov=.5,  kern='gauss',
measurementError=TRUE, diag1D='none', useGAM = FALSE, returnCov=TRUE)
res2$beta0
##
start_time <- Sys.time()
res2 <- ConcurReg(vars, outGrid, userBwMu = .5, userBwCov=.5,  kern='gauss',
measurementError=TRUE, diag1D='none', useGAM = FALSE, returnCov=TRUE)
end_time <- Sys.time()
end_time - start_time
GetCI_Sparse = function(vars, outGrid, level = 0.95, R = 10, userBwMu = .5, userBwCov=.5,
kern='gauss', measurementError=TRUE, diag1D='none', useGAM = FALSE, returnCov=TRUE){
if (length(level) > 1) {
level = level[1]
warning("The input level has more than 1 element; only the first one is used.")
}
if (level < 0 | level > 1) {
stop("Invalid input value of level.")
}
if (R %% 1 != 0 | R < 0) {
stop("R should be an positive integer.")
}
n <- lengthVars(vars)
p <- length(vars) - 1
betaMat <- lapply(1:R, function(b) {
ind <- sample(x = seq_len(n), size = n, replace = TRUE)
for(j in 1:(p+1)){
if ( is.list(vars[[j]]) ) {
vars[[j]]$Lt = vars[[j]]$Lt[ind]
vars[[j]]$Ly = vars[[j]]$Ly[ind]
}else{
vars[[j]] = vars[[j]][ind]
}
}
#res <- ConcurReg(vars, outGrid, userBwMu = .5, userBwCov=.5,  kern='gauss', measurementError=TRUE, diag1D='none', useGAM = FALSE, returnCov=TRUE)
res <- ConcurReg(vars, outGrid, userBwMu = userBwMu, userBwCov = userBwCov,  kern = kern,
measurementError = measurementError, diag1D = diag1D, useGAM = useGAM , returnCov = returnCov)
length(res$beta0)
return(list(beta0 = res$beta0, beta = res$beta, R2 = res$R2, outGrid = res$outGrid))
})
CI_beta0 = apply(t(sapply(1:R, function(b){
betaMat[[b]]$beta0[ complete.cases(betaMat[[b]]$beta0)]
}, simplify = TRUE)), 2,
stats::quantile, c((1-level)/2, 1-(1-level)/2))
CI_beta0 = data.frame(CI_beta0.lower = CI_beta0[1,], CI_beta0.upper = CI_beta0[2,], CIgrid = betaMat[[1]]$outGrid)
CI_beta = lapply(1:p, function(j){
ci_beta_df =  data.frame( t(apply(t(sapply(1:R, function(b){
betaMat[[b]]$beta[j,][ complete.cases(betaMat[[b]]$beta[j,])]
})), 2, stats::quantile, c((1-level)/2, 1-(1-level)/2))))
names(ci_beta_df) =  c( sprintf("CI_beta%d.lower", j)  ,sprintf("CI_beta%d.upper", j))
ci_beta_df$CIgrid = betaMat[[1]]$outGrid
return(ci_beta_df)
})
names(CI_beta) = sapply(1:p, function(j) { sprintf("CI_beta%d", j)})
CI_R2 = apply(t(sapply(1:R, function(b){
betaMat[[b]]$R2[complete.cases(betaMat[[b]]$R2)]
})), 2, stats::quantile, c((1-level)/2, 1-(1-level)/2))
CI_R2 = data.frame(CI_R2.lower = CI_R2[1,], CI_R2.upper = CI_R2[2,], CIgrid = betaMat[[1]]$outGrid)
return(list(CI_beta0 = CI_beta0, CI_beta = CI_beta, CI_R2 = CI_R2,
outGrid = outGrid, level = level))
}
set.seed(1)
n <- 30
nGridIn <- 100
sparsity <- 5:10 # Sparse data sparsity
T <- round(seq(0, 1, length.out=nGridIn), 4) # Functional data support
bw <- 0.1
outGrid <- round(seq(min(T), 1, by=0.05), 2)
# Simulate functional data
mu <- T * 2 # mean function for X_1
sigma <- 1
beta_0 <- 0
beta <- rbind(cos(T), 1.5 + sin(T))
beta_2 <- 1
Z <- MASS::mvrnorm(n, rep(0, 2), diag(2))
X_1 <- Z[, 1, drop=FALSE] %*% matrix(1, 1, nGridIn) + matrix(mu, n, nGridIn, byrow=TRUE)
epsilon <- rnorm(n, sd=sigma)
Y <- matrix(NA, n, nGridIn)
for (i in seq_len(n)) {
Y[i, ] <- beta_0 + beta[1,] * X_1[i, ] + beta[2,] * Z[i, 2] + epsilon[i]
}
# Sparsify functional data
set.seed(1)
X_1sp <- fdapace::Sparsify(X_1, T, sparsity)
Ysp <- fdapace::Sparsify(Y, T, sparsity)
vars <- list(X_1=X_1sp, Z_2=Z[, 2], Y=Ysp)
res <-  GetCI_Sparse(vars, outGrid, level = 0.95, R = 10,
userBwMu = .5, userBwCov = .5,
kern='gauss', measurementError=TRUE, diag1D='none',
useGAM = FALSE, returnCov=TRUE)
level = 0.95
R = 10
userBwMu = .5
userBwCov = .5
kern='gauss'
measurementError=TRUE
diag1D='none'
useGAM = FALSE
returnCov=TRUE
userBwCov = NULL
userBwMu = NULL
if (length(level) > 1) {
level = level[1]
warning("The input level has more than 1 element; only the first one is used.")
}
if (level < 0 | level > 1) {
stop("Invalid input value of level.")
}
if (R %% 1 != 0 | R < 0) {
stop("R should be an positive integer.")
}
n <- lengthVars(vars)
p <- length(vars) - 1
betaMat <- lapply(1:R, function(b) {
ind <- sample(x = seq_len(n), size = n, replace = TRUE)
for(j in 1:(p+1)){
if ( is.list(vars[[j]]) ) {
vars[[j]]$Lt = vars[[j]]$Lt[ind]
vars[[j]]$Ly = vars[[j]]$Ly[ind]
}else{
vars[[j]] = vars[[j]][ind]
}
}
#res <- ConcurReg(vars, outGrid, userBwMu = .5, userBwCov=.5,  kern='gauss', measurementError=TRUE, diag1D='none', useGAM = FALSE, returnCov=TRUE)
res <- ConcurReg(vars, outGrid, userBwMu = userBwMu, userBwCov = userBwCov,  kern = kern,
measurementError = measurementError, diag1D = diag1D, useGAM = useGAM , returnCov = returnCov)
length(res$beta0)
return(list(beta0 = res$beta0, beta = res$beta, R2 = res$R2, outGrid = res$outGrid))
})
CI_beta0 = apply(t(sapply(1:R, function(b){
betaMat[[b]]$beta0[ complete.cases(betaMat[[b]]$beta0)]
}, simplify = TRUE)), 2,
stats::quantile, c((1-level)/2, 1-(1-level)/2))
b = 1
betaMat[[b]]$beta0
t(sapply(1:R, function(b){
betaMat[[b]]$beta0[ complete.cases(betaMat[[b]]$beta0)]
}, simplify = TRUE))
CI_beta = lapply(1:p, function(j){
ci_beta_df =  data.frame( t(apply(t(sapply(1:R, function(b){
betaMat[[b]]$beta[j,][ complete.cases(betaMat[[b]]$beta[j,])]
})), 2, stats::quantile, c((1-level)/2, 1-(1-level)/2))))
names(ci_beta_df) =  c( sprintf("CI_beta%d.lower", j)  ,sprintf("CI_beta%d.upper", j))
ci_beta_df$CIgrid = betaMat[[1]]$outGrid
return(ci_beta_df)
})
setwd("C:/Users/satar/OneDrive - University of California, Davis/docs/Research/tFDAconcur")
devtools::load_all()
devtools::document()
A <- list.files('tests/testthat')
setwd('tests/testthat')
for(i in 1:length(A)) {print(A[i]); source(A[i])}
devtools::build()
devtools::check()
#In R:
usethis::use_build_ignore(c(".travis.yml","inst/testdata","ISSUE_TEMPLATE.md","tests")) #ignore the files we don't include in the released version
devtools::spell_check()
devtools::check_rhub(".", env_vars = c(`_R_CHECK_FORCE_SUGGESTS_` = "false",
`_R_CHECK_CRAN_INCOMING_USE_ASPELL_` = "true"))
devtools::check_win_devel()
revdepcheck::revdep_check()
usethis::use_cran_comments()
devtools::revdep("fdaconcur")
