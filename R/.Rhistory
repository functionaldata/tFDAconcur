myPartition =   c(1:10, sample(10, length(tt)-10, replace=TRUE));
yy = split(yy, myPartition)
tt = split(tt, myPartition)
dataType = 'Sparse';
}
t = unlist(tt);
y = unlist(yy)[order(t)];
t = sort(t);
# r = diff(range(t))
N = length(t);
r = t[N] - t[1];
# Specify the starting bandwidth candidates
if ( dataType == "Sparse") {
dstar = Minb(t, npoly+2);
if ( dstar > r*0.25){
dstar = dstar * 0.75;
warning( c( "The min bandwidth choice is too big, reduce to ", dstar, "!\n"))
}
h0 = 2.5 * dstar;
}else if(dataType == "DenseWithMV"){
h0 = 2.0 * Minb(t, npoly+1);
} else {
h0 = 1.5 * Minb(t,npoly+1);
}
if ( is.nan(h0) ){
if ( kernel == "gauss" ){
h0 = 0.2 * r;
}else{
stop("The data is too sparse, no suitable bandwidth can be found! Try Gaussian kernel instead!\n")
}
}
h0 <- min(h0,r)
q = (r/(4*h0))^(1/9);
bwCandidates = sort(q^(0:9)*h0) ;
# idx = apply(X= sapply(X=t, FUN='==',  ...=sort(unique(t)) ),MARGIN=2, FUN=which)
idx =  pracma::uniq(t)$n; # pracma
# This is to make sure we get the same as MATLAB PACE
# I would write them in a function (equivalent of mykernel.m) if it is worth it
# Similarly there is no reason to repeat the FOR-loop twice; this too can go into a seperate function
k0_candidates <- list('quar' = 0.9375,  'epan' = 0.7500, 'rect' = 0.5000,
'gausvar' = 0.498677, 'gausvar1' = 0.598413,  'gausvar2' = 0.298415, 'other' = 0.398942)
if( any(names(k0_candidates) == kernel)){
k0 = as.numeric(k0_candidates[kernel])
} else {
k0 =  as.numeric(k0_candidates$other)
}
gcvScores <- c()
# Get the corresponding GCV scores
for(i in 1:length(bwCandidates)){
# newmu = Lwls1D(bwCandidates[i], kern=kernel, npoly=npoly, nder=nder, xin = t,yin= y,xout= sort(unique(t)))[idx]
newmu = Lwls1D(bwCandidates[i], kernel_type=kernel, npoly=npoly, nder=nder, xin = t,yin= y, win = rep(1,length(y)),xout= sort(unique(t)))[idx]
cvsum = sum((newmu -y)^2 )
gcvScores[i] =cvsum/(1-(r*k0)/(N*bwCandidates[i]))^2
}
# If no bandwith gives a finite gcvScore increase the candidate bandwith and retry on a finer grid
if(all((is.infinite(gcvScores)))){
bwCandidates = seq( max(bwCandidates), r, length.out = 2*length(bwCandidates))
for(i in 1:length(bwCandidates)){
# newmu = Lwls1D(bwCandidates[i], kern=kernel, npoly=npoly, nder=nder, xin = t,yin= y,xout= sort(unique(t)))[idx]
newmu = Lwls1D(bwCandidates[i], kernel_type =kernel, npoly=npoly, nder=nder, xin = t,yin= y, win = rep(1,length(y)), xout= sort(unique(t)))[idx]
cvsum = sum((newmu -y)^2 )
gcvScores[i] =cvsum/(1-(r*k0)/(N*bwCandidates[i]))^2
}
}
# If the problem persist we clearly have too sparse data
if(all((is.infinite(gcvScores)))){
stop("The data is too sparse, no suitable bandwidth can be found! Try Gaussian kernel instead!\n")
}
bInd = which(gcvScores == min(gcvScores));
bScr = gcvScores[bInd][1]
bOpt = max(bwCandidates[bInd]);
if( bOpt == r){
warning("data is too sparse, optimal bandwidth includes all the data!You may want to change to Gaussian kernel!\n")
}
bOptList <- list( 'bOpt' = bOpt, 'bScore' = bScr)
return( bOptList)
}
xmu <- GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1], optns)[['mu']]
Minb <- function(x, numPoints){
n = length(x);
if( (numPoints<1) || (numPoints > n) ){
warning("Invalid number of minimum points specified\n")
return(NaN)
}
if('legacyCode' == TRUE){
x = sort(unique(x));     # Unique is added to ensure that we do not have a degenerate design
if(numPoints > 1){
return( max(x[numPoints:n]-x[1:(n-numPoints+1)]) )
}else{
return( max(   (x[2:n]-x[1:(n-1)])/2)   )
}
}
gridPts <- sort(unique(x))
distNN1 <- max(diff(gridPts, lag=numPoints))
return(distNN1)
}
xmu <- GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1], optns)[['mu']]
userBwMu=NULL
userBwCov=NULL
is.null(userBwM)
is.null(userBwMu)
optns <- SetOptions(x[['Ly']], x[['Lt']], list(userBwMu=userBwMu, methodBwMu ='GCV', kernel=kern))
optns$userBwMu
optns <- SetOptions(x[['Ly']], x[['Lt']], list(userBwMu=userBwMu, methodBwMu ='GCV', kernel=kern))
xmu <- GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1], optns)[['mu']]
muFun <- approxfun(Tin, xmu)
x[['Ly']] <- lapply(1:length(x[['Ly']]), function(i)
x[['Ly']][[i]]- muFun(x[['Lt']][[i]]))
xmu <- muFun
x <- vars[[2]]
is.numeric(x)
xmu <- mean(x)
x <- x - xmu
x <- vars[[3]]
is.numeric(x)
is.list(x)
Tin <- sort(unique(unlist(x[['Lt']])))
if(is.null(userBwMu)){ # bandwidth choice for mean function is using GCV
optns <- SetOptions(x[['Ly']], x[['Lt']], list(userBwMu=userBwMu, methodBwMu ='GCV', kernel=kern))
xmu <- GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1], optns)[['mu']]
} else{
xmu <- GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1],
list(userBwMu=userBwMu, kernel=kern))[['mu']]
}
muFun <- approxfun(Tin, xmu)
x[['Ly']] <- lapply(1:length(x[['Ly']]), function(i)
x[['Ly']][[i]]- muFun(x[['Lt']][[i]]))
xmu <- muFun
demean <- function(vars, userBwMu, kern) {
tmp <- lapply(vars, function(x) {
if (is.numeric(x)) { # scalar
xmu <- mean(x)
x <- x - xmu
} else if (is.list(x)) { # functional
Tin <- sort(unique(unlist(x[['Lt']])))
if(is.null(userBwMu)){ # bandwidth choice for mean function is using GCV
optns <- SetOptions(x[['Ly']], x[['Lt']], list(userBwMu=userBwMu, methodBwMu ='GCV', kernel=kern))
xmu <- GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1], optns)[['mu']]
} else{
xmu <- GetSmoothedMeanCurve(x[['Ly']], x[['Lt']] , Tin, Tin[1],
list(userBwMu=userBwMu, kernel=kern))[['mu']]
}
muFun <- approxfun(Tin, xmu)
x[['Ly']] <- lapply(1:length(x[['Ly']]), function(i)
x[['Ly']][[i]]- muFun(x[['Lt']][[i]]))
xmu <- muFun
}
list(x=x, mu=xmu)
})
xList <- lapply(tmp, `[[`, 'x')
muList <- lapply(tmp, `[[`, 'mu')
list(xList = xList, muList = muList)
}
# De-mean.
demeanedRes <- demean(vars, userBwMu, kern)
vars <- demeanedRes[['xList']]
muList <- demeanedRes[['muList']]
measurementError
if (!is.list(vars) || length(vars) < 1)
stop('`vars` needs to be a list of length >= 1')
if (diag1D == 'all' && measurementError) {
stop("Cannot assume measurement error when diag1D == 'all'")
}
isFuncVars <- sapply(vars, is.list)
p <- length(isFuncVars)
p
isFuncVars
pFunc <- sum(isFuncVars)
pFunc
pScaler <- sum(!isFuncVars)
pScaler
any(isFuncVars)
tAll <- do.call(c, lapply(vars[isFuncVars], function(x) unlist(x[['Lt']])))
Tin <- sort(unique(tAll))
if (missing(outGrid))
outGrid <- Tin
lenoutGrid <- length(outGrid)
if (any(isFuncVars)) {
tAll <- do.call(c, lapply(vars[isFuncVars], function(x) unlist(x[['Lt']])))
Tin <- sort(unique(tAll))
if (missing(outGrid))
outGrid <- Tin
lenoutGrid <- length(outGrid)
} else {
stop('No functional observation found')
}
if (any(isFuncVars)) {
tAll <- do.call(c, lapply(vars[isFuncVars], function(x) unlist(x[['Lt']])))
Tin <- sort(unique(tAll))
if (missing(outGrid))
outGrid <- Tin
lenoutGrid <- length(outGrid)
} else {
stop('No functional observation found')
}
# First two dimensions are for s, t, and the last two dimensions are for matrix of # random variables.
res <- array(NA, c(lenoutGrid, lenoutGrid, p, p))
j=1
i=1
use1D <- diag1D == 'all' || ( diag1D == 'cross' && j != i )
X <- vars[[1]]
Y <- vars[[1]]
measurementError
rmDiag = (i == j)
rmDiag = (i == j) && measurementError
rmDiag
flagScalerFunc <- FALSE
!is.list(X) && is.list(Y)
# Force X to be a function in the scalar-function case.
if (!is.list(X) && is.list(Y)) {
flagScalerFunc <- TRUE
tmp <- X
X <- Y
Y <- tmp
}
TinX <- sort(unique(unlist(X[['Lt']])))
TinY <- sort(unique(unlist(Y[['Lt']])))
noutGrid <- length(outGrid)
center
center=TRUE
center
if (min(TinX) > min(outGrid) || min(TinY) > min(outGrid) ||
max(TinY) < max(outGrid) || max(TinX) < max(outGrid))
stop('Observation time points coverage too low')
is.null(userBwCov)
userBwCov
optns <- SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
optns$userBwCov
userBwCov=NULL
optns <- SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
optns$userBwMu
Xmu <- GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], TinX, TinX[1], optns)[['mu']]
is.null(userBwCov)
optns <- SetOptions(Y[['Ly']], Y[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
optns$methodBwMu
Ymu <- GetSmoothedMeanCurve(Y[['Ly']], Y[['Lt']], TinX, TinX[1], optns)[['mu']]
Xmu <- rep(0, length(TinX))
Ymu <- rep(0, length(TinY))
names(Xmu) <- TinX
names(Ymu) <- TinY
TinX
Xvec <- unlist(X[['Ly']])
Yvec <- unlist(Y[['Ly']])
tvecX <- unlist(X[['Lt']])
tvecY <- unlist(Y[['Lt']])
!identical(tvecX, tvecY)
identical(tvecX, tvecY)
ord <- order(tvecX)
tvecX <- tvecX[ord]
Xvec <- Xvec[ord]
Yvec <- Yvec[ord]
Xcent <- Xvec - Xmu[as.character(tvecX)]
Ycent <- Yvec - Ymu[as.character(tvecX)]
is.null(userBwCov)
optns <- SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
optns$dataType
bw_mu =  unlist(GCVLwls1D1(yy = Xcent * Ycent, tt = tvecX, kernel = kern, npoly = 1, nder = 0, dataType = optns$dataType) )[1]
bw_mu
max(tvecX)
min(tvecX)
covXY <- Lwls1D(userBwCov=bw_mu, kern, npoly=1L, nder=0L, xin=tvecX, yin=Xcent * Ycent, win=rep(1, length(tvecX)), xout=outGrid)
rmDiag
tmp <- GetCrCovYX(userBwCov, userBwCov, X[['Ly']], X[['Lt']], Xmu,
Y[['Ly']], Y[['Lt']], Ymu, rmDiag=rmDiag, kern=kern)
gd <- tmp[['smoothGrid']]
userBwCov
userBwCov
res <- matrix(
interp2lin(as.numeric(gd[, 1]),
as.numeric(gd[, 2]),
matrix(as.numeric(tmp[['smoothedCC']]),
nrow(tmp[['smoothedCC']]),
ncol(tmp[['smoothedCC']])),
rep(as.numeric(outGrid), times=noutGrid),
rep(as.numeric(outGrid), each=noutGrid)),
noutGrid, noutGrid)
CPPlwls1d <- function(bw, kernel_type, win, xin, yin, xout, npoly = 1L, nder = 0L) {
.Call('_fdapaceTemp_CPPlwls1d', PACKAGE = 'fdapaceTemp', bw, kernel_type, win, xin, yin, xout, npoly, nder)
}
GetIndCEScoresCPP <- function(yVec, muVec, lamVec, phiMat, SigmaYi) {
.Call('_fdapaceTemp_GetIndCEScoresCPP', PACKAGE = 'fdapaceTemp', yVec, muVec, lamVec, phiMat, SigmaYi)
}
GetIndCEScoresCPPnewInd <- function(yVec, muVec, lamVec, phiMat, SigmaYi, newPhi, newMu) {
.Call('_fdapaceTemp_GetIndCEScoresCPPnewInd', PACKAGE = 'fdapaceTemp', yVec, muVec, lamVec, phiMat, SigmaYi, newPhi, newMu)
}
RCPPmean <- function(X) {
.Call('_fdapaceTemp_RCPPmean', PACKAGE = 'fdapaceTemp', X)
}
RCPPvar <- function(X) {
.Call('_fdapaceTemp_RCPPvar', PACKAGE = 'fdapaceTemp', X)
}
RcppPseudoApprox <- function(X, Y, X_target) {
.Call('_fdapaceTemp_RcppPseudoApprox', PACKAGE = 'fdapaceTemp', X, Y, X_target)
}
Rcppsort <- function(v) {
.Call('_fdapaceTemp_Rcppsort', PACKAGE = 'fdapaceTemp', v)
}
Rmullwlsk <- function(bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, bwCheck, transp = TRUE) {
.Call('_fdapaceTemp_Rmullwlsk', PACKAGE = 'fdapaceTemp', bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, bwCheck, transp)
}
RmullwlskCC <- function(bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, bwCheck) {
.Call('_fdapaceTemp_RmullwlskCC', PACKAGE = 'fdapaceTemp', bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, bwCheck)
}
RmullwlskCCsort2 <- function(bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, bwCheck) {
.Call('_fdapaceTemp_RmullwlskCCsort2', PACKAGE = 'fdapaceTemp', bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, bwCheck)
}
RmullwlskUniversal <- function(bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, bwCheck, autoCov) {
.Call('_fdapaceTemp_RmullwlskUniversal', PACKAGE = 'fdapaceTemp', bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, bwCheck, autoCov)
}
RmullwlskUniversalDeriv <- function(bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, npoly, nder1, nder2, bwCheck, autoCov) {
.Call('_fdapaceTemp_RmullwlskUniversalDeriv', PACKAGE = 'fdapaceTemp', bw, kernel_type, tPairs, cxxn, win, xgrid, ygrid, npoly, nder1, nder2, bwCheck, autoCov)
}
Rrotatedmullwlsk <- function(bw, kernel_type, tPairs, cxxn, win, xygrid, npoly, bwCheck) {
.Call('_fdapaceTemp_Rrotatedmullwlsk', PACKAGE = 'fdapaceTemp', bw, kernel_type, tPairs, cxxn, win, xygrid, npoly, bwCheck)
}
#' Cumulative Trapezoid Rule Numerical Integration
#'
#' Cumulative Trapezoid Rule Numerical Integration using Rcpp
#' @param X Sorted vector of X values
#' @param Y Vector of Y values.
#' @export
cumtrapzRcpp <- function(X, Y) {
.Call('_fdapaceTemp_cumtrapzRcpp', PACKAGE = 'fdapaceTemp', X, Y)
}
dropZeroElementsXYWin <- function(win, xin, yin) {
.Call('_fdapaceTemp_dropZeroElementsXYWin', PACKAGE = 'fdapaceTemp', win, xin, yin)
}
interp2lin <- function(xin, yin, zin, xou, you) {
.Call('_fdapaceTemp_interp2lin', PACKAGE = 'fdapaceTemp', xin, yin, zin, xou, you)
}
#' Trapezoid Rule Numerical Integration
#'
#' Trapezoid Rule Numerical Integration using Rcpp
#' @param X Sorted vector of X values
#' @param Y Vector of Y values.
#' @export
trapzRcpp <- function(X, Y) {
.Call('_fdapaceTemp_trapzRcpp', PACKAGE = 'fdapaceTemp', X, Y)
}
res <- matrix(
interp2lin(as.numeric(gd[, 1]),
as.numeric(gd[, 2]),
matrix(as.numeric(tmp[['smoothedCC']]),
nrow(tmp[['smoothedCC']]),
ncol(tmp[['smoothedCC']])),
rep(as.numeric(outGrid), times=noutGrid),
rep(as.numeric(outGrid), each=noutGrid)),
noutGrid, noutGrid)
interp2lin <- function(xin, yin, zin, xou, you) {
.Call('_fdapace_interp2lin', PACKAGE = 'fdapace', xin, yin, zin, xou, you)
}
res <- matrix(
interp2lin(as.numeric(gd[, 1]),
as.numeric(gd[, 2]),
matrix(as.numeric(tmp[['smoothedCC']]),
nrow(tmp[['smoothedCC']]),
ncol(tmp[['smoothedCC']])),
rep(as.numeric(outGrid), times=noutGrid),
rep(as.numeric(outGrid), each=noutGrid)),
noutGrid, noutGrid)
if (use1D) {
Xvec <- unlist(X[['Ly']])
Yvec <- unlist(Y[['Ly']])
tvecX <- unlist(X[['Lt']])
tvecY <- unlist(Y[['Lt']])
if (!identical(tvecX, tvecY)){
stop('Cannot use 1D covariance smoothing if the observation time points for X and Y are different')
}
ord <- order(tvecX)
tvecX <- tvecX[ord]
Xvec <- Xvec[ord]
Yvec <- Yvec[ord]
Xcent <- Xvec - Xmu[as.character(tvecX)]
Ycent <- Yvec - Ymu[as.character(tvecX)]
if(is.null(userBwCov)){
optns <- SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
bw_mu =  unlist(GCVLwls1D1(yy = Xcent * Ycent, tt = tvecX, kernel = kern, npoly = 1, nder = 0, dataType = optns$dataType) )[1]
covXY <- Lwls1D(userBwCov=bw_mu, kern, npoly=1L, nder=0L, xin=tvecX, yin=Xcent * Ycent, win=rep(1, length(tvecX)), xout=outGrid)
}else{
covXY <- Lwls1D(userBwCov=userBwCov, kern, npoly=1L, nder=0L, xin=tvecX, yin=Xcent * Ycent, win=rep(1, length(tvecX)), xout=outGrid)
}
res <- matrix(NA, noutGrid, noutGrid)
diag(res) <- covXY
} else { # use 2D smoothing
tmp <- GetCrCovYX(userBwCov, userBwCov, X[['Ly']], X[['Lt']], Xmu,
Y[['Ly']], Y[['Lt']], Ymu, rmDiag=rmDiag, kern=kern)
gd <- tmp[['smoothGrid']]
res <- matrix(
interp2lin(as.numeric(gd[, 1]),
as.numeric(gd[, 2]),
matrix(as.numeric(tmp[['smoothedCC']]),
nrow(tmp[['smoothedCC']]),
ncol(tmp[['smoothedCC']])),
rep(as.numeric(outGrid), times=noutGrid),
rep(as.numeric(outGrid), each=noutGrid)),
noutGrid, noutGrid)
}
attr(res, 'covType') <- 'FF'
# Scalar-scalar
if (!is.list(X) && !is.list(Y)) {
res <- cov(X, Y)
attr(res, 'covType') <- 'SS'
# Scalar-function
} else if (is.list(X) && !is.list(Y)) {
Tin <- sort(unique(unlist(X[['Lt']])))
if (center) {
Xmu <- GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], Tin, Tin[1], list(userBwMu=userBwCov, kernel=kern))[['mu']]
Ymu <- mean(Y)
} else {
Xmu <- rep(0, length(Tin))
Ymu <- 0
}
res <- GetCrCovYZ(userBwCov, Y, Ymu, X[['Ly']], X[['Lt']], Xmu, Tin, kern)[['smoothedCC']]
res <- as.matrix(ConvertSupport(Tin, outGrid, mu=res))
if (flagScalerFunc)
res <- t(res)
attr(res, 'covType') <- 'FS'
# function-function
} else {
TinX <- sort(unique(unlist(X[['Lt']])))
TinY <- sort(unique(unlist(Y[['Lt']])))
noutGrid <- length(outGrid)
if (center) {
if (min(TinX) > min(outGrid) || min(TinY) > min(outGrid) ||
max(TinY) < max(outGrid) || max(TinX) < max(outGrid))
stop('Observation time points coverage too low')
if(is.null(userBwCov)){ # bandwidth choice for mean function is using GCV
optns <- SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
Xmu <- GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], TinX, TinX[1], optns)[['mu']]
} else{
Xmu <- GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], TinX, TinX[1],
list(userBwMu=userBwCov, kernel=kern))[['mu']]
}
if(is.null(userBwCov)){
optns <- SetOptions(Y[['Ly']], Y[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
Ymu <- GetSmoothedMeanCurve(Y[['Ly']], Y[['Lt']], TinX, TinX[1], optns)[['mu']]
}else{
Ymu <- GetSmoothedMeanCurve(Y[['Ly']], Y[['Lt']], TinY, TinY[1], list(userBwMu=userBwCov, kernel=kern))[['mu']]
}
} else {
Xmu <- rep(0, length(TinX))
Ymu <- rep(0, length(TinY))
}
names(Xmu) <- TinX
names(Ymu) <- TinY
if (use1D) {
Xvec <- unlist(X[['Ly']])
Yvec <- unlist(Y[['Ly']])
tvecX <- unlist(X[['Lt']])
tvecY <- unlist(Y[['Lt']])
if (!identical(tvecX, tvecY)){
stop('Cannot use 1D covariance smoothing if the observation time points for X and Y are different')
}
ord <- order(tvecX)
tvecX <- tvecX[ord]
Xvec <- Xvec[ord]
Yvec <- Yvec[ord]
Xcent <- Xvec - Xmu[as.character(tvecX)]
Ycent <- Yvec - Ymu[as.character(tvecX)]
if(is.null(userBwCov)){
optns <- SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
bw_mu =  unlist(GCVLwls1D1(yy = Xcent * Ycent, tt = tvecX, kernel = kern, npoly = 1, nder = 0, dataType = optns$dataType) )[1]
covXY <- Lwls1D(userBwCov=bw_mu, kern, npoly=1L, nder=0L, xin=tvecX, yin=Xcent * Ycent, win=rep(1, length(tvecX)), xout=outGrid)
}else{
covXY <- Lwls1D(userBwCov=userBwCov, kern, npoly=1L, nder=0L, xin=tvecX, yin=Xcent * Ycent, win=rep(1, length(tvecX)), xout=outGrid)
}
res <- matrix(NA, noutGrid, noutGrid)
diag(res) <- covXY
} else { # use 2D smoothing
tmp <- GetCrCovYX(userBwCov, userBwCov, X[['Ly']], X[['Lt']], Xmu,
Y[['Ly']], Y[['Lt']], Ymu, rmDiag=rmDiag, kern=kern)
gd <- tmp[['smoothGrid']]
res <- matrix(
interp2lin(as.numeric(gd[, 1]),
as.numeric(gd[, 2]),
matrix(as.numeric(tmp[['smoothedCC']]),
nrow(tmp[['smoothedCC']]),
ncol(tmp[['smoothedCC']])),
rep(as.numeric(outGrid), times=noutGrid),
rep(as.numeric(outGrid), each=noutGrid)),
noutGrid, noutGrid)
}
attr(res, 'covType') <- 'FF'
}
X <- vars[[1]]
Y< - vars[[2]]
Y <- NULL
Y <- vars[[2]]
flagScalerFunc <- FALSE
# Force X to be a function in the scalar-function case.
if (!is.list(X) && is.list(Y)) {
flagScalerFunc <- TRUE
tmp <- X
X <- Y
Y <- tmp
}
is.list(X) && !is.list(Y)
Tin <- sort(unique(unlist(X[['Lt']])))
userBwCov
Tin <- sort(unique(unlist(X[['Lt']])))
if(is.null(userBwCov)){ # bandwidth choice for mean function is using GCV
optns <- SetOptions(X[['Ly']], X[['Lt']], list(userBwMu=userBwCov, methodBwMu ='GCV', kernel=kern))
Xmu <- GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], Tin, Tin[1], optns)[['mu']]
} else{
Xmu <- GetSmoothedMeanCurve(X[['Ly']], X[['Lt']], Tin, Tin[1],
list(userBwMu=userBwCov, kernel=kern))[['mu']]
}
Ymu <- mean(Y)
res <- GetCrCovYZ(userBwCov, Y, Ymu, X[['Ly']], X[['Lt']], Xmu, Tin, kern)[['smoothedCC']]
res <- as.matrix(ConvertSupport(Tin, outGrid, mu=res))
if (flagScalerFunc)
res <- t(res)
